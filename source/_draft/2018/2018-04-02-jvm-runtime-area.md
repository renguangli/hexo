---
layout: post
title: Java虚拟机 - 运行时数据区域
categories: Java虚拟机
tags: [Java,Java虚拟机]
---

Java虚拟机把它所管理的内存划分为程序计数器、虚拟机栈、本地方法栈、堆、方法区、运行时常量池、直接内存等几个区域。

其中堆和方法区是线程共享的，其他内存区域是线程私有的。

![Java虚拟机内存结构](/images/jvm/runtime-area.jpg)

## 运行时数据区域

以下是对各个内存区域的简单介绍

### 程序计数器

程序计数器是当前线程执行字节码的行号指示器，它的作用记录当前线程所执行的字节码行号，用于获取下一条执行的字节码。

线程执行 Java 方法时记录的是正在执行的虚拟机字节码指令的地址，执行 Native 方法时记录的是空。

此内存区域是唯一一个在Java虚拟机规范中没有规定任何 OutOfMemoryError 情况的内存区域。

### 虚拟机栈

虚拟机栈由一个一个的栈帧组成，栈帧是 Java 方法执行的内存模型。

每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法的执行到结束对应栈帧的压栈和出栈。

虚拟机栈规定的异常情况有两种：
- 线程请求的栈的深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；
- 如果虚拟机可以动态扩展，如果扩展时无法申请到足够的内存，就抛出 OutOfMemoryError 异常

### 本地方法栈

和Java虚拟机栈很类似，不同的是本地方法栈为 Native 方法服务。

### Java 堆

Java 堆是虚拟机所管理内存区域中最大的一块，在虚拟机启动时创建，几乎所有的对象都是在这个区域进行内存分配。

堆中可细分为新生代和老年代，新生代又可分为 Eden空间、From Survivor 空间、To Survivor 空间。

堆无法扩展时，抛出 OutOfMemoryError 异常

### 方法区

方法区存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

当方法区无法满足内存分配需求时，抛出 OutOfMemoryError
 
### 运行时常量池

运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池（Const Pool Table），用于存放编译期生成的各种字面量和符号引用。并非预置入 Class 文件中常量池的内容才进入方法运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。

当方法区无法满足内存分配需求时，抛出 OutOfMemoryError

### 直接内存

直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。
 
JDK1.4 加入了 NIO，引入一种基于通道与缓冲区的 I/ O方式，它可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。避免了在 Java 堆和 Native 堆中来回复制数据，提高了性能。
 
当各个内存区域总和大于物理内存限制，抛出 OutOfMemoryError 异常。